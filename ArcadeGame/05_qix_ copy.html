<!DOCTYPE html>
<html>
<head>
    <title>Qix</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        canvas {
            border: 2px solid #444;
            background: #000;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth - 4;
        canvas.height = window.innerHeight - 4;

        const FPS = 60;
        const PLAYER_SPEED = 3;
        const QIX_SPEED = 1.5;
        const FILL_THRESHOLD = 0.75;

        let player = {
            x: canvas.width/2,
            y: canvas.height - 20,
            angle: 0,
            drawing: false,
            path: [],
            safe: true
        };

        let qix = {
            points: [],
            speed: QIX_SPEED,
            direction: Math.random() * Math.PI * 2
        };

        let sparx = [];
        let claimedArea = 0;
        let gameOver = false;
        let gameWon = false;
        let score = 0;

        // Inizializzazione
        function init() {
            resizeCanvas();
            createQix();
            createSparx();
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
        }

        // Creazione Qix
        function createQix() {
            qix.points = [];
            for (let i = 0; i < 10; i++) {
                qix.points.push({
                    x: canvas.width/2 + Math.cos(i * Math.PI/5) * 50,
                    y: canvas.height/2 + Math.sin(i * Math.PI/5) * 50
                });
            }
        }

        // Creazione Sparx
        function createSparx() {
            sparx = [];
            for (let i = 0; i < 2; i++) {
                sparx.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() < 0.5 ? 0 : canvas.height,
                    angle: Math.random() * Math.PI * 2,
                    speed: 2
                });
            }
        }

        // Ridimensionamento canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth - 4;
            canvas.height = window.innerHeight - 4;
        }

        // Gestione tasti
        function handleKeyDown(e) {
            if (e.code === 'Space' && !player.drawing && !gameOver) {
                player.drawing = true;
                player.path = [{x: player.x, y: player.y}];
                player.safe = false;
            }
        }

        function handleKeyUp(e) {
            if (e.code === 'Space' && player.drawing) {
                player.drawing = false;
                checkFill();
            }
        }

        // Aggiornamento gioco
        function update() {
            if (gameOver || gameWon) return;

            movePlayer();
            moveQix();
            moveSparx();
            checkCollisions();
        }

        // Movimento giocatore
        function movePlayer() {
            const edge = 20;
            const speed = player.drawing ? PLAYER_SPEED * 0.5 : PLAYER_SPEED;

            if (player.drawing) {
                const angle = Math.atan2(
                    player.y - player.path[0].y,
                    player.x - player.path[0].x
                );
                
                player.x += Math.cos(angle) * speed;
                player.y += Math.sin(angle) * speed;
                
                player.path.push({x: player.x, y: player.y});
            } else {
                player.angle += 0.05;
                
                player.x = (canvas.width/2 + Math.cos(player.angle) * (canvas.width/2 - edge));
                player.y = (canvas.height/2 + Math.sin(player.angle) * (canvas.height/2 - edge));
            }
        }

        // Movimento Qix
        function moveQix() {
            qix.direction += (Math.random() - 0.5) * 0.1;
            
            for (let point of qix.points) {
                point.x += Math.cos(qix.direction) * qix.speed;
                point.y += Math.sin(qix.direction) * qix.speed;
                
                // Contenimento
                point.x = Math.max(0, Math.min(canvas.width, point.x));
                point.y = Math.max(0, Math.min(canvas.height, point.y));
            }
        }

        // Movimento Sparx
        function moveSparx() {
            for (let spark of sparx) {
                spark.x += Math.cos(spark.angle) * spark.speed;
                spark.y += Math.sin(spark.angle) * spark.speed;
                
                // Rimbalzo ai bordi
                if (spark.x < 0 || spark.x > canvas.width) spark.angle = Math.PI - spark.angle;
                if (spark.y < 0 || spark.y > canvas.height) spark.angle = -spark.angle;
            }
        }

        // Controllo collisioni
        function checkCollisions() {
            // Collisione Qix con linea giocatore
            if (!player.safe) {
                for (let i = 0; i < qix.points.length-1; i++) {
                    const x1 = qix.points[i].x;
                    const y1 = qix.points[i].y;
                    const x2 = qix.points[i+1].x;
                    const y2 = qix.points[i+1].y;
                    
                    for (let j = 0; j < player.path.length-1; j++) {
                        const x3 = player.path[j].x;
                        const y3 = player.path[j].y;
                        const x4 = player.path[j+1].x;
                        const y4 = player.path[j+1].y;
                        
                        if (lineIntersect(x1,y1,x2,y2,x3,y3,x4,y4)) {
                            gameOver = true;
                        }
                    }
                }
            }

            // Collisione Sparx con linea giocatore
            if (!player.safe) {
                for (let spark of sparx) {
                    for (let i = 0; i < player.path.length-1; i++) {
                        const x1 = player.path[i].x;
                        const y1 = player.path[i].y;
                        const x2 = player.path[i+1].x;
                        const y2 = player.path[i+1].y;
                        
                        const dist = distance(spark.x, spark.y, x1, y1, x2, y2);
                        if (dist < 5) gameOver = true;
                    }
                }
            }
        }

        // Controllo riempimento area
        function checkFill() {
            if (player.path.length < 2) return;
            
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.moveTo(player.path[0].x, player.path[0].y);
            for (let point of player.path) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.closePath();
            
            const pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const total = canvas.width * canvas.height;
            let count = 0;
            
            for (let i = 0; i < pixels.data.length; i += 4) {
                if (pixels.data[i+3] > 0) count++;
            }
            
            const newArea = count / total;
            if (newArea > 0.01) {
                claimedArea += newArea;
                ctx.fill();
                player.safe = true;
                score += Math.floor(newArea * 1000);
            }
        }

        // Disegno
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Area reclamata
            ctx.fillStyle = '#080';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Disegno Qix
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(qix.points[0].x, qix.points[0].y);
            for (let point of qix.points) {
                ctx.lineTo(point.x, point.y);
            }
            ctx.closePath();
            ctx.stroke();
            
            // Disegno Sparx
            ctx.fillStyle = '#f00';
            for (let spark of sparx) {
                ctx.beginPath();
                ctx.arc(spark.x, spark.y, 5, 0, Math.PI*2);
                ctx.fill();
            }
            
            // Disegno giocatore
            ctx.strokeStyle = '#0ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(player.x, player.y, 10, 0, Math.PI*2);
            ctx.stroke();
            
            // Disegno linea giocatore
            if (player.drawing) {
                ctx.beginPath();
                ctx.moveTo(player.path[0].x, player.path[0].y);
                for (let point of player.path) {
                    ctx.lineTo(point.x, point.y);
                }
                ctx.stroke();
            }
            
            // UI
            ctx.fillStyle = '#fff';
            ctx.font = '20px Arial';
            ctx.fillText(`Area: ${(claimedArea*100).toFixed(1)}%`, 20, 40);
            ctx.fillText(`Score: ${score}`, 20, 80);
            
            if (gameOver) {
                ctx.font = '40px Arial';
                ctx.fillText('GAME OVER', canvas.width/2 - 120, canvas.height/2);
            }
            
            if (claimedArea >= FILL_THRESHOLD) {
                gameWon = true;
                ctx.font = '40px Arial';
                ctx.fillText('STAGE CLEAR!', canvas.width/2 - 140, canvas.height/2);
            }
        }

        // Game loop
        function gameLoop() {
            update();
            draw();
            setTimeout(() => requestAnimationFrame(gameLoop), 1000/FPS);
        }

        // Helper functions
        function lineIntersect(a,b,c,d,p,q,r,s) {
            const det = (c - a)*(s - q) - (r - p)*(d - b);
            if (det === 0) return false;
            const lambda = ((s - q)*(r - a) + (p - r)*(s - b)) / det;
            const gamma = ((b - d)*(r - a) + (c - a)*(s - b)) / det;
            return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
        }

        function distance(x0, y0, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const len = Math.sqrt(dx*dx + dy*dy);
            const t = ((x0 - x1)*dx + (y0 - y1)*dy)/len**2;
            const projX = x1 + t*dx;
            const projY = y1 + t*dy;
            return Math.hypot(x0 - projX, y0 - projY);
        }

        init();
        gameLoop();
    </script>
</body>
</html>